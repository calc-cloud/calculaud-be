# Production environment values for calculaud-be
# Override default values for production environment

# Multiple replicas for high availability
replicaCount: 5

# Production image configuration
image:
  tag: "latest"
  pullPolicy: IfNotPresent

# Production configuration
config:
  debug: false
  environment: "production"

# External managed PostgreSQL for production
postgresql:
  external:
    host: "production-postgres.example.com"
    port: 5432
    username: "calculaud_prod"
    password: "CHANGE_ME"  # Override with external secret management
    database: "calculaud_prod"

# Production S3 configuration  
s3:
  accessKeyId: "CHANGE_ME"      # Override with external secret management
  secretAccessKey: "CHANGE_ME"  # Override with external secret management
  region: "us-east-1"
  endpointUrl: ""  # Use AWS S3
  bucketName: "calculaud-prod-files"
  bucketUrl: "https://calculaud-prod-files.s3.amazonaws.com"
  useSsl: true
  storageClass: "STANDARD"

# Production authentication
auth:
  jwksUrl: "https://auth.example.com/.well-known/jwks.json"
  issuer: "https://auth.example.com/"
  audience: "calculaud-api"
  tokenEndpointUrl: "https://auth.example.com/oauth/token"
  oidcUrl: "https://auth.example.com/"
  oauth:
    clientId: "calculaud-prod-client"

# Use external secret management in production
existingSecret: "calculaud-prod-secrets"

# Production ingress with SSL
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "1024m"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    # Rate limiting for production
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
  hosts:
    - host: api.calculaud.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: calculaud-prod-tls
      hosts:
        - api.calculaud.com

# Production resource requirements
resources:
  requests:
    memory: "512Mi"
    cpu: "200m"
  limits:
    memory: "1Gi"
    cpu: "1000m"

# Enable autoscaling for production
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 75

# Production node selection (if using node labels)
nodeSelector:
  node-type: "application"

# Production tolerations (if using taints)
tolerations:
  - key: "application-only"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

# Production affinity rules for high availability
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - calculaud-be
        topologyKey: kubernetes.io/hostname

# Production health checks
healthcheck:
  liveness:
    initialDelaySeconds: 45
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readiness:
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  startup:
    initialDelaySeconds: 15
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30

# Production-specific environment variables
extraEnvVars:
  - name: LOG_LEVEL
    value: "INFO"
  - name: WORKERS
    value: "4"

# Service annotations for production monitoring
service:
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8000"
    prometheus.io/path: "/metrics"