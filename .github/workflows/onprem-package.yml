# On-Premises Package Creation Workflow
# Creates deployment packages for air-gapped/offline environments

name: Create On-Premises Package

on:
  # Primary trigger: Create packages for releases
  release:
    types: [published]
  
  # Secondary trigger: Manual package creation
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to package'
        required: false
        default: 'latest'
        type: string
      package_name:
        description: 'Custom package name suffix'
        required: false
        default: ''
        type: string
      include_monitoring:
        description: 'Include monitoring components'
        required: false
        default: false
        type: boolean

  # Note: Removed auto-packaging on main branch push to avoid conflicts
  # with k8s-deploy.yml. Use manual dispatch or releases instead.

permissions:
  contents: write  # Needed to upload release assets

jobs:
  # Determine package configuration
  determine-config:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.determine-tag.outputs.image_tag }}
      package_suffix: ${{ steps.determine-tag.outputs.package_suffix }}
    steps:
    - name: Determine image tag and package naming
      id: determine-tag
      run: |
        # Determine image tag and package suffix based on trigger
        if [[ "${{ github.event_name }}" == "release" ]]; then
          IMAGE_TAG="${{ github.event.release.tag_name }}"
          PACKAGE_SUFFIX="${{ github.event.release.tag_name }}"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          PACKAGE_SUFFIX="${{ github.event.inputs.package_name }}"
          [[ -z "$IMAGE_TAG" ]] && IMAGE_TAG="latest"
          [[ -z "$PACKAGE_SUFFIX" ]] && PACKAGE_SUFFIX="custom-$(date +'%Y%m%d-%H%M%S')"
        elif [[ "${{ github.event_name }}" == "push" ]]; then
          TIMESTAMP="$(date +'%Y%m%d-%H%M%S')"
          IMAGE_TAG="main-$TIMESTAMP"
          PACKAGE_SUFFIX="main-$TIMESTAMP"
        else
          TIMESTAMP="$(date +'%Y%m%d-%H%M%S')"
          IMAGE_TAG="latest"
          PACKAGE_SUFFIX="$TIMESTAMP"
        fi
        
        # Set outputs
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "package_suffix=$PACKAGE_SUFFIX" >> $GITHUB_OUTPUT
        
        echo "âœ… Image tag: $IMAGE_TAG"
        echo "âœ… Package suffix: $PACKAGE_SUFFIX"

    - name: Verify build readiness
      run: |
        REPOSITORY=$(k8s/scripts/get-chart-config.sh repository)
        echo "âœ… Ready to build image: $REPOSITORY:${{ steps.determine-tag.outputs.image_tag }}"
        echo "Build context available, proceeding with image creation."

  # Create the on-premises deployment package
  create-package:
    runs-on: ubuntu-latest
    needs: determine-config
    outputs:
      package_file: ${{ steps.package.outputs.package_file }}
      package_size: ${{ steps.package.outputs.package_size }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    
    - name: Build and tag Docker image
      run: |
        echo "ðŸ—ï¸ Building Docker image for packaging..."
        
        # Get repository from Chart.yaml
        REPOSITORY=$(k8s/scripts/get-chart-config.sh repository)
        
        # Build the application image
        docker build -t $REPOSITORY:${{ needs.determine-config.outputs.image_tag }} .
        
        # Optional monitoring images (if requested)
        if [[ "${{ github.event.inputs.include_monitoring }}" == "true" ]]; then
          echo "Pulling monitoring images..."
          docker pull prom/prometheus:latest
          docker pull grafana/grafana:latest
        fi
        
        echo "âœ… Images ready for packaging"
        docker images

    - name: Make packaging script executable
      run: chmod +x k8s/scripts/package-for-onprem.sh

    - name: Create on-premises package
      id: package
      run: |
        echo "ðŸ—ï¸ Creating on-premises deployment package..."
        
        # Set custom output filename
        PACKAGE_NAME="calculaud-onprem-${{ needs.determine-config.outputs.package_suffix }}"
        
        # Create package
        ./k8s/scripts/package-for-onprem.sh \
          --output "${PACKAGE_NAME}.tar.gz" \
          --compress-level 6 \
          --image-tag "${{ needs.determine-config.outputs.image_tag }}" \
          --skip-build
        
        # Get package info
        PACKAGE_FILE="${PACKAGE_NAME}.tar.gz"
        PACKAGE_SIZE=$(du -h "$PACKAGE_FILE" | cut -f1)
        
        echo "package_file=$PACKAGE_FILE" >> $GITHUB_OUTPUT
        echo "package_size=$PACKAGE_SIZE" >> $GITHUB_OUTPUT
        
        # Generate checksum
        sha256sum "$PACKAGE_FILE" > "$PACKAGE_FILE.sha256"
        
        echo "âœ… Package created: $PACKAGE_FILE ($PACKAGE_SIZE)"
        ls -la *.tar.gz*

    - name: Upload package as artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.package.outputs.package_file }}
        path: |
          ${{ steps.package.outputs.package_file }}
          ${{ steps.package.outputs.package_file }}.sha256
        retention-days: 30
        compression-level: 0  # Package is already compressed

    # Upload to release if this was triggered by a release
    - name: Upload to GitHub Release
      if: github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ${{ steps.package.outputs.package_file }}
          ${{ steps.package.outputs.package_file }}.sha256
        tag_name: ${{ github.event.release.tag_name }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Create package manifest and documentation
  create-manifest:
    runs-on: ubuntu-latest
    needs: [create-package]
    steps:
    - name: Create deployment manifest
      run: |
        cat > deployment-manifest.md << EOF
        # Calculaud On-Premises Deployment Package
        
        **Package**: \`${{ needs.create-package.outputs.package_file }}\`
        **Size**: ${{ needs.create-package.outputs.package_size }}
        **Created**: $(date -u)
        **Image Tag**: ${{ needs.determine-config.outputs.image_tag }}
        **Trigger**: ${{ github.event_name }}
        
        ## Contents
        
        REPOSITORY=$(k8s/scripts/get-chart-config.sh repository)
        - âœ… Application Docker image (\`$REPOSITORY:${{ needs.determine-config.outputs.image_tag }}\`)
        
        ## External Dependencies (Expected to be Available)
        
        - ðŸ”— PostgreSQL database (external)
        - ðŸ”— S3-compatible storage (external AWS S3/etc.)
        - âœ… Kubernetes Helm charts
        - âœ… Deployment scripts
        - âœ… Configuration templates
        - âœ… Installation documentation
        
        ## Deployment Instructions
        
        1. **Transfer package** to on-premises environment:
           \`\`\`bash
           scp ${{ needs.create-package.outputs.package_file }} user@onprem-server:/opt/
           \`\`\`
        
        2. **Extract and deploy**:
           \`\`\`bash
           tar -xzf ${{ needs.create-package.outputs.package_file }}
           cd \${package_dir}
           ./install.sh
           \`\`\`
        
        3. **Verify deployment**:
           \`\`\`bash
           kubectl get pods -n calculaud
           \`\`\`
        
        ## Requirements
        
        - Kubernetes cluster (1.24+)
        - kubectl configured
        - Helm 3.8+
        - Docker (for loading images)
        - 8GB+ RAM, 50GB+ storage
        
        ## Support
        
        - Documentation: See included \`docs/DEPLOYMENT_GUIDE.md\`
        - Health checks: \`http://your-app/health\`
        - API docs: \`http://your-app/docs\`
        EOF

    - name: Upload manifest as artifact
      uses: actions/upload-artifact@v4
      with:
        name: deployment-manifest-${{ needs.determine-config.outputs.package_suffix }}
        path: deployment-manifest.md
        retention-days: 30

  # Notification and summary
  notify:
    runs-on: ubuntu-latest
    needs: [create-package, create-manifest]
    if: always()
    steps:
    - name: Package creation summary
      run: |
        echo "## ðŸ“¦ On-Premises Package Creation Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ needs.create-package.result }}" == "success" ]]; then
          echo "âœ… **Package created successfully!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Package**: \`${{ needs.create-package.outputs.package_file }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Size**: ${{ needs.create-package.outputs.package_size }}" >> $GITHUB_STEP_SUMMARY
          REPOSITORY=$(k8s/scripts/get-chart-config.sh repository)
          echo "- **Image**: \`$REPOSITORY:${{ needs.determine-config.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "ðŸ“Ž Package has been attached to the GitHub release." >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“Ž Package is available in the workflow artifacts." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Instructions" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the package from artifacts or release assets" >> $GITHUB_STEP_SUMMARY
          echo "2. Transfer to your on-premises environment" >> $GITHUB_STEP_SUMMARY
          echo "3. Extract and run: \`./install.sh\`" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ **Package creation failed!**" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
        fi