# Kubernetes deployment workflow using Helm
# Deploys to different environments based on branch/tag

name: Deploy to Kubernetes

on:
  push:
    branches: 
      - main
      - develop
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - prod
        - eks
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'

permissions:
  contents: read
  packages: read

jobs:
  # Determine deployment environment and image tag
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.env.outputs.image_tag }}
      namespace: ${{ steps.env.outputs.namespace }}
    steps:
    - name: Determine environment and image tag
      id: env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "release" ]]; then
          echo "environment=prod" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=prod" >> $GITHUB_OUTPUT
          echo "image_tag=main-$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
        else
          echo "environment=dev" >> $GITHUB_OUTPUT
          echo "image_tag=dev-latest" >> $GITHUB_OUTPUT
        fi
        
        # Set namespace based on environment
        case "${{ steps.env.outputs.environment || 'dev' }}" in
          prod)
            echo "namespace=calculaud-prod" >> $GITHUB_OUTPUT
            ;;
          eks)
            echo "namespace=calculaud-prod" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "namespace=calculaud-dev" >> $GITHUB_OUTPUT
            ;;
        esac

  # Deploy to development environment
  deploy-dev:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment == 'dev'
    environment: development
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl for development cluster
      run: |
        echo "Configuring kubectl for development cluster"
        # Add your development cluster configuration here
        # Example for different cloud providers:
        
        # For AWS EKS:
        # aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.DEV_EKS_CLUSTER_NAME }}
        
        # For Azure AKS:
        # az aks get-credentials --resource-group ${{ secrets.DEV_RESOURCE_GROUP }} --name ${{ secrets.DEV_AKS_CLUSTER_NAME }}
        
        # For Google GKE:
        # gcloud container clusters get-credentials ${{ secrets.DEV_GKE_CLUSTER_NAME }} --zone ${{ secrets.DEV_GKE_ZONE }}
        
        # For generic kubeconfig:
        echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Deploy to development
      run: |
        # Deploy using simplified deployment script
        ./k8s/scripts/deploy.sh -e dev -n ${{ needs.setup.outputs.namespace }}
        
        # Override image tag if specified
        if [[ "${{ needs.setup.outputs.image_tag }}" != "latest" ]]; then
          helm upgrade calculaud-be k8s/helm/calculaud-be \
            --namespace ${{ needs.setup.outputs.namespace }} \
            --reuse-values \
            --set image.tag=${{ needs.setup.outputs.image_tag }}
        fi

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/calculaud-be -n ${{ needs.setup.outputs.namespace }}
        kubectl get pods -n ${{ needs.setup.outputs.namespace }} -l app.kubernetes.io/name=calculaud-be

  # Deploy to production environment (prod or eks)
  deploy-prod:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment == 'prod' || needs.setup.outputs.environment == 'eks'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl for production cluster
      run: |
        echo "Configuring kubectl for production cluster"
        # Add your production cluster configuration here
        # Use the same pattern as development but with production secrets
        echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Run database migrations
      run: |
        # Run migrations before deployment
        ./k8s/scripts/migrate.sh -n ${{ needs.setup.outputs.namespace }}

    - name: Create production secrets
      run: |
        # Create temporary values file with secrets from GitHub secrets
        cat > prod-secrets.yaml << EOF
        postgresql:
          external:
            host: "${{ secrets.PROD_DB_HOST }}"
            username: "${{ secrets.PROD_DB_USERNAME }}"
            password: "${{ secrets.PROD_DB_PASSWORD }}"
            database: "${{ secrets.PROD_DB_NAME }}"
        
        s3:
          accessKeyId: "${{ secrets.PROD_S3_ACCESS_KEY }}"
          secretAccessKey: "${{ secrets.PROD_S3_SECRET_KEY }}"
          bucketName: "${{ secrets.PROD_S3_BUCKET }}"
          bucketUrl: "${{ secrets.PROD_S3_BUCKET_URL }}"
        
        auth:
          jwksUrl: "${{ secrets.PROD_AUTH_JWKS_URL }}"
          issuer: "${{ secrets.PROD_AUTH_ISSUER }}"
          audience: "${{ secrets.PROD_AUTH_AUDIENCE }}"
          tokenEndpointUrl: "${{ secrets.PROD_AUTH_TOKEN_URL }}"
          oidcUrl: "${{ secrets.PROD_AUTH_OIDC_URL }}"
          oauth:
            clientId: "${{ secrets.PROD_OAUTH_CLIENT_ID }}"
        
        ingress:
          hosts:
            - host: "${{ secrets.PROD_DOMAIN }}"
              paths:
                - path: /
                  pathType: Prefix
          tls:
            - secretName: calculaud-prod-tls
              hosts:
                - "${{ secrets.PROD_DOMAIN }}"
        EOF

    - name: Deploy to production
      run: |
        # Determine deployment environment (prod or eks)
        DEPLOY_ENV="${{ needs.setup.outputs.environment }}"
        
        # Deploy using simplified deployment script
        ./k8s/scripts/deploy.sh -e "$DEPLOY_ENV" -n ${{ needs.setup.outputs.namespace }}
        
        # Apply secrets overlay and update image tag
        helm upgrade calculaud-be k8s/helm/calculaud-be \
          --namespace ${{ needs.setup.outputs.namespace }} \
          --reuse-values \
          --values prod-secrets.yaml \
          --set image.tag=${{ needs.setup.outputs.image_tag }} \
          --wait \
          --timeout=900s
        
        # Cleanup secrets file
        rm -f prod-secrets.yaml

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/calculaud-be -n ${{ needs.setup.outputs.namespace }}
        kubectl get pods -n ${{ needs.setup.outputs.namespace }} -l app.kubernetes.io/name=calculaud-be

    - name: Run post-deployment tests
      run: |
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=calculaud-be -n ${{ needs.setup.outputs.namespace }} --timeout=300s
        
        # Test health endpoints
        kubectl run test-pod --rm -i --restart=Never --image=curlimages/curl -- \
          curl -f http://calculaud-be.${{ needs.setup.outputs.namespace }}.svc.cluster.local/health/ready

  # Notify on deployment completion
  notify:
    runs-on: ubuntu-latest
    needs: [setup, deploy-dev, deploy-prod]
    if: always()
    steps:
    - name: Deployment notification
      run: |
        if [[ "${{ needs.deploy-dev.result }}" == "success" || "${{ needs.deploy-prod.result }}" == "success" ]]; then
          echo "✅ Deployment to ${{ needs.setup.outputs.environment }} completed successfully!"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Image Tag: ${{ needs.setup.outputs.image_tag }}"
          echo "Namespace: ${{ needs.setup.outputs.namespace }}"
        else
          echo "❌ Deployment failed"
          exit 1
        fi