# Kubernetes deployment workflow using Helm
# Deploys to different environments based on branch/tag

name: Deploy to Kubernetes

on:
  push:
    branches: 
      - main
  pull_request:
    types: [opened, synchronize, reopened, closed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - pr
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'
      pr_branch:
        description: 'Branch name for PR deployment (auto-detected if empty)'
        required: false
        default: ''

permissions:
  contents: read
  packages: read

jobs:
  # Determine deployment environment and image tag
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.env.outputs.image_tag }}
      namespace: ${{ steps.env.outputs.namespace }}
    steps:
    - name: Determine environment and image tag
      id: env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          
          # Handle PR environment branch naming
          if [[ "${{ github.event.inputs.environment }}" == "pr" ]]; then
            if [[ -n "${{ github.event.inputs.pr_branch }}" ]]; then
              BRANCH_NAME="${{ github.event.inputs.pr_branch }}"
            else
              BRANCH_NAME="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
            fi
            
            # Sanitize branch name for Kubernetes namespace
            SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | cut -c1-50)
            echo "pr_branch_name=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          fi
        elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" ]]; then
          echo "environment=cleanup" >> $GITHUB_OUTPUT
          echo "image_tag=none" >> $GITHUB_OUTPUT
          
          # Get branch name for cleanup
          BRANCH_NAME="${{ github.head_ref }}"
          SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | cut -c1-50)
          echo "pr_branch_name=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "image_tag=main-$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
        else
          echo "environment=none" >> $GITHUB_OUTPUT
          echo "image_tag=none" >> $GITHUB_OUTPUT
        fi
        
        # Set namespace based on environment
        case "${{ steps.env.outputs.environment || 'none' }}" in
          staging)
            echo "namespace=calculaud-staging" >> $GITHUB_OUTPUT
            ;;
          pr)
            echo "namespace=calculaud-${{ steps.env.outputs.pr_branch_name }}" >> $GITHUB_OUTPUT
            ;;
          cleanup)
            echo "namespace=calculaud-${{ steps.env.outputs.pr_branch_name }}" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "namespace=calculaud-staging" >> $GITHUB_OUTPUT
            ;;
        esac

  # Deploy to staging environment
  deploy-staging:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment == 'staging'
    environment: staging
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl for staging cluster
      run: |
        echo "Configuring kubectl for staging cluster"
        # Add your staging cluster configuration here
        # For generic kubeconfig:
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Generate staging values from template
      env:
        # Core configuration (automatically injected from staging environment)
        ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
        IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        AWS_REGION: ${{ vars.AWS_REGION }}
        
        # Environment-specific configuration
        ENVIRONMENT: "staging"
        REPLICA_COUNT: ${{ vars.REPLICA_COUNT }}
        DEBUG: ${{ vars.DEBUG }}
        
        # Database configuration (secrets from staging environment)
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_PORT: ${{ vars.DB_PORT }}
        DB_USERNAME: ${{ secrets.DB_USERNAME }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        DB_NAME: ${{ vars.DB_NAME }}
        
        # S3 configuration (secrets from staging environment)
        S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
        S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
        S3_BUCKET: ${{ vars.S3_BUCKET }}
        S3_BUCKET_URL: ${{ vars.S3_BUCKET_URL }}
        S3_KEY_PREFIX: ${{ vars.S3_KEY_PREFIX }}
        
        # Authentication configuration (mixed secrets/vars from staging environment)
        AUTH_JWKS_URL: ${{ vars.AUTH_JWKS_URL }}
        AUTH_ISSUER: ${{ vars.AUTH_ISSUER }}
        AUTH_AUDIENCE: ${{ vars.AUTH_AUDIENCE }}
        AUTH_TOKEN_URL: ${{ vars.AUTH_TOKEN_URL }}
        AUTH_OIDC_URL: ${{ vars.AUTH_OIDC_URL }}
        OAUTH_CLIENT_ID: ${{ vars.OAUTH_CLIENT_ID }}
        
        # Infrastructure configuration (vars from staging environment)
        INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED }}
        INGRESS_CLASS: ${{ vars.INGRESS_CLASS }}
        DOMAIN: ${{ vars.DOMAIN }}
        SSL_CERT_ARN: ${{ vars.SSL_CERT_ARN }}
        SERVICE_ACCOUNT_ROLE_ARN: ${{ vars.SERVICE_ACCOUNT_ROLE_ARN }}
        
        # Resource configuration (vars from staging environment)
        RESOURCES_REQUEST_MEMORY: ${{ vars.RESOURCES_REQUEST_MEMORY }}
        RESOURCES_REQUEST_CPU: ${{ vars.RESOURCES_REQUEST_CPU }}
        RESOURCES_LIMIT_MEMORY: ${{ vars.RESOURCES_LIMIT_MEMORY }}
        RESOURCES_LIMIT_CPU: ${{ vars.RESOURCES_LIMIT_CPU }}
        
        # Autoscaling configuration (vars from staging environment)
        AUTOSCALING_ENABLED: ${{ vars.AUTOSCALING_ENABLED }}
        AUTOSCALING_MIN_REPLICAS: ${{ vars.AUTOSCALING_MIN_REPLICAS }}
        AUTOSCALING_MAX_REPLICAS: ${{ vars.AUTOSCALING_MAX_REPLICAS }}
        
        # Health check configuration (vars from staging environment)
        HEALTHCHECK_LIVENESS_INITIAL_DELAY: ${{ vars.HEALTHCHECK_LIVENESS_INITIAL_DELAY }}
        HEALTHCHECK_READINESS_FAILURE_THRESHOLD: ${{ vars.HEALTHCHECK_READINESS_FAILURE_THRESHOLD }}
        
        # Application configuration (vars from staging environment)
        LOG_LEVEL: ${{ vars.LOG_LEVEL }}
        WORKERS: ${{ vars.WORKERS }}
        MAX_FILE_SIZE_MB: ${{ vars.MAX_FILE_SIZE_MB }}
        DEFAULT_PAGE_SIZE: ${{ vars.DEFAULT_PAGE_SIZE }}
        
        # Optional existing secret
        EXISTING_SECRET: ${{ vars.EXISTING_SECRET }}
      run: |
        echo "üîÑ Generating staging values from template..."
        
        # Generate values file from universal template
        envsubst < k8s/helm/calculaud-be/values.yaml.template > values-staging-generated.yaml
        
        echo "‚úÖ Generated staging values file"
        echo "üìã Preview of generated configuration:"
        head -20 values-staging-generated.yaml

    - name: Validate generated template
      run: |
        echo "üîç Validating generated template..."
        
        # Check for any remaining unsubstituted variables
        if grep -q '\${' values-staging-generated.yaml; then
          echo "‚ùå Found unsubstituted variables in generated file:"
          grep '\${' values-staging-generated.yaml || true
          echo "::error::Template generation failed - unsubstituted variables found"
          exit 1
        fi
        
        # Validate YAML syntax
        if ! python -c "import yaml; yaml.safe_load(open('values-staging-generated.yaml'))" 2>/dev/null; then
          echo "‚ùå Generated YAML is invalid"
          echo "::error::Generated values file contains invalid YAML"
          exit 1
        fi
        
        echo "‚úÖ Template validation passed"

    - name: Deploy to staging
      run: |
        # Deploy using Helm with generated values file
        helm upgrade calculaud-be k8s/helm/calculaud-be \
          --install \
          --namespace ${{ needs.setup.outputs.namespace }} \
          --values values-staging-generated.yaml \
          --wait \
          --timeout=600s
        
        echo "‚úÖ Staging deployment completed"

    - name: Cleanup generated files
      if: always()
      run: |
        # Remove generated values files for security
        rm -f values-staging-generated.yaml

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/calculaud-be -n ${{ needs.setup.outputs.namespace }}
        kubectl get pods -n ${{ needs.setup.outputs.namespace }} -l app.kubernetes.io/name=calculaud-be

  # Deploy to PR environment
  deploy-pr:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment == 'pr'
    environment: testing
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl for PR deployment
      run: |
        echo "Configuring kubectl for PR deployment"
        # Use staging cluster for PR deployments
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Create PR namespace
      run: |
        # Create namespace if it doesn't exist
        kubectl create namespace ${{ needs.setup.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Generate PR values from template
      env:
        # Core configuration (automatically injected from testing environment)
        ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
        IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        AWS_REGION: ${{ vars.AWS_REGION }}
        
        # Environment-specific configuration
        ENVIRONMENT: "testing"
        REPLICA_COUNT: ${{ vars.REPLICA_COUNT }}
        DEBUG: ${{ vars.DEBUG }}
        
        # PR Branch information for S3 key prefix
        PR_BRANCH_NAME: ${{ needs.setup.outputs.pr_branch_name }}
        
        # Database configuration (secrets from testing environment - shared test DB)
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_PORT: ${{ vars.DB_PORT }}
        DB_USERNAME: ${{ secrets.DB_USERNAME }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        DB_NAME: ${{ vars.DB_NAME }}
        
        # S3 configuration (secrets from testing environment - shared test bucket)
        S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
        S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
        S3_BUCKET: ${{ vars.S3_BUCKET }}
        S3_BUCKET_URL: ${{ vars.S3_BUCKET_URL }}
        S3_KEY_PREFIX: "pr-files/${{ needs.setup.outputs.pr_branch_name }}/"
        
        # Authentication configuration (mixed secrets/vars from testing environment)
        AUTH_JWKS_URL: ${{ vars.AUTH_JWKS_URL }}
        AUTH_ISSUER: ${{ vars.AUTH_ISSUER }}
        AUTH_AUDIENCE: ${{ vars.AUTH_AUDIENCE }}
        AUTH_TOKEN_URL: ${{ vars.AUTH_TOKEN_URL }}
        AUTH_OIDC_URL: ${{ vars.AUTH_OIDC_URL }}
        OAUTH_CLIENT_ID: ${{ vars.OAUTH_CLIENT_ID }}
        
        # Infrastructure configuration (vars from testing environment - minimal)
        INGRESS_ENABLED: ${{ vars.INGRESS_ENABLED }}
        
        # Resource configuration (vars from testing environment - minimal)
        RESOURCES_REQUEST_MEMORY: ${{ vars.RESOURCES_REQUEST_MEMORY }}
        RESOURCES_REQUEST_CPU: ${{ vars.RESOURCES_REQUEST_CPU }}
        RESOURCES_LIMIT_MEMORY: ${{ vars.RESOURCES_LIMIT_MEMORY }}
        RESOURCES_LIMIT_CPU: ${{ vars.RESOURCES_LIMIT_CPU }}
        
        # Health check configuration (vars from testing environment - faster)
        HEALTHCHECK_LIVENESS_INITIAL_DELAY: ${{ vars.HEALTHCHECK_LIVENESS_INITIAL_DELAY }}
        HEALTHCHECK_READINESS_FAILURE_THRESHOLD: ${{ vars.HEALTHCHECK_READINESS_FAILURE_THRESHOLD }}
        
        # Application configuration (vars from testing environment)
        LOG_LEVEL: ${{ vars.LOG_LEVEL }}
        WORKERS: ${{ vars.WORKERS }}
        MAX_FILE_SIZE_MB: ${{ vars.MAX_FILE_SIZE_MB }}
        DEFAULT_PAGE_SIZE: ${{ vars.DEFAULT_PAGE_SIZE }}
        
        # Optional existing secret
        EXISTING_SECRET: ${{ vars.EXISTING_SECRET }}
      run: |
        echo "üîÑ Generating PR values from template..."
        echo "üìù PR Branch: $PR_BRANCH_NAME"
        echo "üìù PR Namespace: ${{ needs.setup.outputs.namespace }}"
        
        # Generate values file from universal template
        envsubst < k8s/helm/calculaud-be/values.yaml.template > values-pr-generated.yaml
        
        echo "‚úÖ Generated PR values file"
        echo "üìã Preview of generated configuration:"
        head -15 values-pr-generated.yaml

    - name: Validate generated PR template
      run: |
        echo "üîç Validating generated PR template..."
        
        # Check for any remaining unsubstituted variables (except optional ones)
        if grep -q '\${[^}]*}' values-pr-generated.yaml; then
          echo "‚ö†Ô∏è  Found potentially unsubstituted variables in generated file:"
          grep '\${[^}]*}' values-pr-generated.yaml || true
          
          # Check if they're required variables (fail) or optional ones (warn)
          if grep -q '\${TEST_' values-pr-generated.yaml; then
            echo "‚ùå Found unsubstituted required TEST_ variables"
            echo "::error::PR template generation failed - required variables missing"
            exit 1
          else
            echo "‚ÑπÔ∏è  Only optional variables remain unsubstituted (this is OK)"
          fi
        fi
        
        # Validate YAML syntax
        if ! python -c "import yaml; yaml.safe_load(open('values-pr-generated.yaml'))" 2>/dev/null; then
          echo "‚ùå Generated YAML is invalid"
          echo "::error::Generated PR values file contains invalid YAML"
          exit 1
        fi
        
        echo "‚úÖ PR template validation passed"

    - name: Deploy to PR environment
      run: |
        # Deploy using Helm with generated PR values file
        helm upgrade calculaud-be k8s/helm/calculaud-be \
          --install \
          --namespace ${{ needs.setup.outputs.namespace }} \
          --values values-pr-generated.yaml \
          --wait \
          --timeout=300s
        
        echo "‚úÖ PR deployment completed"

    - name: Cleanup generated files
      if: always()
      run: |
        # Remove generated values files for security
        rm -f values-pr-generated.yaml

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/calculaud-be -n ${{ needs.setup.outputs.namespace }}
        kubectl get pods -n ${{ needs.setup.outputs.namespace }} -l app.kubernetes.io/name=calculaud-be

    - name: Get deployment info
      run: |
        echo "üöÄ PR Environment Deployed Successfully!"
        echo "Namespace: ${{ needs.setup.outputs.namespace }}"
        echo "Branch: ${{ needs.setup.outputs.pr_branch_name }}"
        echo "Image Tag: ${{ needs.setup.outputs.image_tag }}"
        
        # Get service info
        kubectl get svc -n ${{ needs.setup.outputs.namespace }}

  # Cleanup PR environment
  cleanup-pr:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment == 'cleanup'
    steps:
    - name: Configure kubectl for cleanup
      run: |
        echo "Configuring kubectl for PR cleanup"
        echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Cleanup PR environment
      run: |
        echo "üßπ Cleaning up PR environment: ${{ needs.setup.outputs.namespace }}"
        
        # Uninstall Helm release if it exists
        if helm list -n ${{ needs.setup.outputs.namespace }} | grep -q calculaud-be; then
          helm uninstall calculaud-be -n ${{ needs.setup.outputs.namespace }}
        fi
        
        # Delete namespace
        if kubectl get namespace ${{ needs.setup.outputs.namespace }} >/dev/null 2>&1; then
          kubectl delete namespace ${{ needs.setup.outputs.namespace }}
          echo "‚úÖ Cleaned up namespace: ${{ needs.setup.outputs.namespace }}"
        else
          echo "‚ÑπÔ∏è  Namespace ${{ needs.setup.outputs.namespace }} does not exist"
        fi

  # Notify on deployment completion
  notify:
    runs-on: ubuntu-latest
    needs: [setup, deploy-staging, deploy-pr, cleanup-pr]
    if: always() && needs.setup.outputs.environment != 'none'
    steps:
    - name: Deployment notification
      run: |
        if [[ "${{ needs.deploy-staging.result }}" == "success" || "${{ needs.deploy-pr.result }}" == "success" || "${{ needs.cleanup-pr.result }}" == "success" ]]; then
          if [[ "${{ needs.setup.outputs.environment }}" == "cleanup" ]]; then
            echo "üßπ PR environment cleanup completed!"
            echo "Cleaned up namespace: ${{ needs.setup.outputs.namespace }}"
          else
            echo "‚úÖ Deployment to ${{ needs.setup.outputs.environment }} completed successfully!"
            echo "Environment: ${{ needs.setup.outputs.environment }}"
            echo "Image Tag: ${{ needs.setup.outputs.image_tag }}"
            echo "Namespace: ${{ needs.setup.outputs.namespace }}"
            if [[ "${{ needs.setup.outputs.environment }}" == "pr" ]]; then
              echo "Branch: ${{ needs.setup.outputs.pr_branch_name }}"
            fi
          fi
        else
          echo "‚ùå Operation failed"
          exit 1
        fi