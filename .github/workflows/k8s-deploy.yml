# Kubernetes deployment workflow using Helm
# Deploys to different environments based on branch/tag

name: Deploy to Kubernetes

on:
  push:
    branches: 
      - main
  pull_request:
    types: [opened, synchronize, reopened, closed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'testing'
        type: choice
        options:
        - staging
        - testing
      image_tag:
        description: 'Docker image tag to deploy (auto-generated if empty)'
        required: false
        default: ''
      pr_number:
        description: 'PR number for deployment (auto-detected if empty)'
        required: false
        default: ''

permissions:
  contents: read
  packages: read
  id-token: write  # Required for AWS OIDC authentication

jobs:
  # Determine deployment environment and image tag
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.env.outputs.image_tag }}
      namespace: ${{ steps.env.outputs.namespace }}
      pr_branch_name: ${{ steps.env.outputs.pr_branch_name }}
      deploy_timeout: ${{ steps.env.outputs.deploy_timeout }}
    steps:
    - name: Determine environment and image tag
      id: env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          
          # Generate image tag if not provided
          if [[ -n "${{ github.event.inputs.image_tag }}" ]]; then
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            # Generate timestamp-based tag
            echo "image_tag=manual-$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
          fi
          
          # Handle testing environment branch naming
          if [[ "${{ github.event.inputs.environment }}" == "testing" ]]; then
            # Get PR info from context or input
            if [[ -n "${{ github.event.inputs.pr_number }}" ]]; then
              PR_NUMBER="${{ github.event.inputs.pr_number }}"
              # Get branch name from PR (this would require API call, simplified for now)
              BRANCH_NAME="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
            else
              BRANCH_NAME="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
            fi
            
            # Sanitize branch name for Kubernetes namespace
            SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | cut -c1-50)
            echo "pr_branch_name=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          fi
        elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" ]]; then
          echo "environment=cleanup" >> $GITHUB_OUTPUT
          echo "image_tag=none" >> $GITHUB_OUTPUT
          
          # Get branch name for cleanup
          BRANCH_NAME="${{ github.head_ref }}"
          SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | cut -c1-50)
          echo "pr_branch_name=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "image_tag=main-$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
        else
          echo "environment=none" >> $GITHUB_OUTPUT
          echo "image_tag=none" >> $GITHUB_OUTPUT
        fi
        
        # Set namespace and timeout based on environment
        case "${{ steps.env.outputs.environment || 'none' }}" in
          staging)
            echo "namespace=calculaud-staging" >> $GITHUB_OUTPUT
            echo "deploy_timeout=600s" >> $GITHUB_OUTPUT
            ;;
          testing)
            echo "namespace=calculaud-${{ steps.env.outputs.pr_branch_name }}" >> $GITHUB_OUTPUT
            echo "deploy_timeout=300s" >> $GITHUB_OUTPUT
            ;;
          cleanup)
            echo "namespace=calculaud-${{ steps.env.outputs.pr_branch_name }}" >> $GITHUB_OUTPUT
            echo "deploy_timeout=300s" >> $GITHUB_OUTPUT
            ;;
          *)
            echo "namespace=calculaud-staging" >> $GITHUB_OUTPUT
            echo "deploy_timeout=600s" >> $GITHUB_OUTPUT
            ;;
        esac

  # Build and push Docker image to ECR
  build-image:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment != 'none' && needs.setup.outputs.environment != 'cleanup'
    outputs:
      image_uri: ${{ steps.image.outputs.image_uri }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_BUILD_ROLE_ARN }}
        aws-region: ${{ vars.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ vars.ECR_REPOSITORY }}
        tags: |
          type=raw,value=${{ needs.setup.outputs.image_tag }}
          type=sha,prefix={{branch}}-
          type=ref,event=branch
          type=ref,event=pr

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Set image URI output
      id: image
      run: |
        IMAGE_URI="${{ vars.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}"
        echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "‚úÖ Built and pushed image: $IMAGE_URI"

  # Unified deployment job for both staging and testing environments
  deploy:
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: contains(fromJSON('["staging", "testing"]'), needs.setup.outputs.environment)
    environment: ${{ needs.setup.outputs.environment }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure kubectl
      run: |
        echo "Configuring kubectl for ${{ needs.setup.outputs.environment }} deployment"
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Create namespace (testing environment only)
      if: needs.setup.outputs.environment == 'testing'
      run: |
        # Create namespace if it doesn't exist (testing environment uses dynamic namespaces)
        kubectl create namespace ${{ needs.setup.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Generate values from template
      env:
        # Dynamic values only (things that change per deployment)
        ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
        IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        
        # Secrets (can't be in template file for security)
        DB_HOST: ${{ secrets.DB_HOST }}
        DB_USERNAME: ${{ secrets.DB_USERNAME }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
        S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
        
        # Everything else (DB_NAME, S3_BUCKET, AUTH_*, REPLICA_COUNT, DEBUG, etc.) 
        # should be configured in template defaults, not here
      run: |
        echo "üîÑ Generating ${{ needs.setup.outputs.environment }} values from template..."
        if [[ "${{ needs.setup.outputs.environment }}" == "testing" ]]; then
          echo "üìù PR Branch: ${{ needs.setup.outputs.pr_branch_name }}"
          echo "üìù PR Namespace: ${{ needs.setup.outputs.namespace }}"
        fi
        
        # Generate values file from universal template
        envsubst < k8s/helm/calculaud-be/values.yaml.template > values-generated.yaml
        
        echo "‚úÖ Generated ${{ needs.setup.outputs.environment }} values file"
        echo "üìã Preview of generated configuration:"
        head -15 values-generated.yaml

    - name: Validate generated template
      run: |
        echo "üîç Validating generated template..."
        
        # Check for any remaining unsubstituted variables (except optional ones with defaults)
        if grep -q '\${[^}]*}' values-generated.yaml; then
          echo "‚ö†Ô∏è  Found potentially unsubstituted variables in generated file:"
          grep '\${[^}]*}' values-generated.yaml || true
          
          # Check if they're required variables (those without defaults) - these should fail
          REQUIRED_VARS="ECR_REPOSITORY|IMAGE_TAG|ENVIRONMENT|DB_HOST|DB_USERNAME|DB_PASSWORD|DB_NAME|S3_ACCESS_KEY|S3_SECRET_KEY|S3_BUCKET|AUTH_JWKS_URL|AUTH_ISSUER|AUTH_AUDIENCE|AUTH_TOKEN_URL|AUTH_OIDC_URL|OAUTH_CLIENT_ID"
          if grep -E "\\\$\{($REQUIRED_VARS)[^}]*\}" values-generated.yaml; then
            echo "‚ùå Found unsubstituted required variables"
            echo "::error::Template generation failed - required variables missing"
            exit 1
          else
            echo "‚ÑπÔ∏è  Only optional variables with defaults remain unsubstituted (this is OK)"
          fi
        fi
        
        # Validate YAML syntax
        if ! python -c "import yaml; yaml.safe_load(open('values-generated.yaml'))" 2>/dev/null; then
          echo "‚ùå Generated YAML is invalid"
          echo "::error::Generated values file contains invalid YAML"
          exit 1
        fi
        
        echo "‚úÖ Template validation passed"

    - name: Deploy application
      run: |
        # Deploy using Helm with generated values file
        helm upgrade calculaud-be k8s/helm/calculaud-be \
          --install \
          --namespace ${{ needs.setup.outputs.namespace }} \
          --values values-generated.yaml \
          --wait \
          --timeout=${{ needs.setup.outputs.deploy_timeout }}
        
        echo "‚úÖ ${{ needs.setup.outputs.environment }} deployment completed"

    - name: Cleanup generated files
      if: always()
      run: |
        # Remove generated values files for security
        rm -f values-generated.yaml

    - name: Verify deployment
      run: |
        kubectl rollout status deployment/calculaud-be -n ${{ needs.setup.outputs.namespace }}
        kubectl get pods -n ${{ needs.setup.outputs.namespace }} -l app.kubernetes.io/name=calculaud-be

    - name: Get deployment info
      run: |
        echo "üöÄ ${{ needs.setup.outputs.environment }} Environment Deployed Successfully!"
        echo "Environment: ${{ needs.setup.outputs.environment }}"
        echo "Namespace: ${{ needs.setup.outputs.namespace }}"
        echo "Image Tag: ${{ needs.setup.outputs.image_tag }}"
        if [[ "${{ needs.setup.outputs.environment }}" == "testing" ]]; then
          echo "Branch: ${{ needs.setup.outputs.pr_branch_name }}"
        fi
        
        # Get service info
        kubectl get svc -n ${{ needs.setup.outputs.namespace }}

  # Cleanup PR environment
  cleanup-pr:
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.environment == 'cleanup'
    steps:
    - name: Configure kubectl for cleanup
      run: |
        echo "Configuring kubectl for PR cleanup"
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Cleanup PR environment
      run: |
        echo "üßπ Cleaning up PR environment: ${{ needs.setup.outputs.namespace }}"
        
        # Uninstall Helm release if it exists
        if helm list -n ${{ needs.setup.outputs.namespace }} | grep -q calculaud-be; then
          helm uninstall calculaud-be -n ${{ needs.setup.outputs.namespace }}
        fi
        
        # Delete namespace
        if kubectl get namespace ${{ needs.setup.outputs.namespace }} >/dev/null 2>&1; then
          kubectl delete namespace ${{ needs.setup.outputs.namespace }}
          echo "‚úÖ Cleaned up namespace: ${{ needs.setup.outputs.namespace }}"
        else
          echo "‚ÑπÔ∏è  Namespace ${{ needs.setup.outputs.namespace }} does not exist"
        fi

  # Notify on deployment completion
  notify:
    runs-on: ubuntu-latest
    needs: [setup, build-image, deploy, cleanup-pr]
    if: always() && needs.setup.outputs.environment != 'none'
    steps:
    - name: Deployment notification
      run: |
        if [[ "${{ needs.deploy.result }}" == "success" || "${{ needs.cleanup-pr.result }}" == "success" ]]; then
          if [[ "${{ needs.setup.outputs.environment }}" == "cleanup" ]]; then
            echo "üßπ PR environment cleanup completed!"
            echo "Cleaned up namespace: ${{ needs.setup.outputs.namespace }}"
          else
            echo "‚úÖ Deployment to ${{ needs.setup.outputs.environment }} completed successfully!"
            echo "Environment: ${{ needs.setup.outputs.environment }}"
            echo "Image Tag: ${{ needs.setup.outputs.image_tag }}"
            echo "Namespace: ${{ needs.setup.outputs.namespace }}"
            if [[ "${{ needs.setup.outputs.environment }}" == "testing" ]]; then
              echo "Branch: ${{ needs.setup.outputs.pr_branch_name }}"
            fi
          fi
        else
          echo "‚ùå Operation failed"
          exit 1
        fi